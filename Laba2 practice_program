#include <iostream> //библиотека для ввода/вывода
#include <iomanip> //библиотека для оформления таблицы
#include <string> //библиотека для работы со строками
#include <vector>
using namespace std; //чтобы каждый раз не писать std::

double x = 10, new_x;
double alpha;
int n = 1; //порядковый номер члена функционального ряда (по условию это 1)
double initial_variable; //наши начальные вычисление
double next_variable; //наши вычисления для следущей переменной
double summa; //сумма для уже имеющихся значений
double En_0; //значение погрешности
vector<int> number;
vector<double> variable_v;
vector<double> summa_v;
vector<double> En_0_v;

double PROVERKA_NA_x() //проверка на введеное значение х
{
int input;
cout << "Enter x: " << endl;
while (!(cin >> input) || (cin.peek() != '\n') || (input < -1) || (input > 1)) //проверка на ограничения
{
cin.clear();
cin.ignore(32767, '\n'); //очистка потока ввода
cout << "Please, enter a correct -1 <= x <= 1 : " << endl;
}
return input;
}

double PROVERKA_NA_alpha() //проверка на введеное значение alpha
{
cout << "Enter alpha: " << endl;
while (!(cin >> alpha) || (cin.peek() != '\n') || (alpha < 0)) //проверка на ограничения
{
cin.clear();
cin.ignore(32767, '\n'); //очистка потока ввода
cout << "Please, enter a correct 0 <= alpha: " << endl;
}
return alpha;
}

void output_table(int n, double a, double s, double En) {
cout << "n = " << std::setw(5) << n <<" | " //setw - установка ширины столбца таблицы
<< "An = " << std::setw(15) << a << " | "
<< "S = " << std::setw(9) << s << " | "
<< "En = " << std::setw(12) << En << " | " << "\n";
}


void calculation(double x, int n) {
number.push_back(n); //push_back - функция библиотеки вектороввводит последним значение из собок в вектор
initial_variable = next_variable;
variable_v.push_back(initial_variable);
summa += initial_variable;
summa_v.push_back(summa);
next_variable = pow(-1, (n + 1)) * ((pow(x, 2 * n)) / (2 * n * (2 * n + 1))); //формула n-ого члена
En_0 = abs(next_variable / summa);
En_0_v.push_back(En_0);
output_table(n, initial_variable, summa, En_0); 
}

int main() {
string result; //введение строковой переменной для повтора дальнейшей работы программы
bool working = true; //вводим условие, при котором работает программа
while (working) //пока наше значение является истиной
{
n = 0;
En_0 = 100;
new_x = PROVERKA_NA_x(); //запускаем заранее написанные функции для проверки и работы программы
alpha = PROVERKA_NA_alpha();
if (new_x == x) { //при повторном вводе сравниваем этот х и предыдущий
if ((alpha == int(alpha) && alpha < number.back()) || (alpha != int(alpha) && En_0_v.back() < alpha))
cout << "The value has already been calculated: \n";
cout << "Previous calculations: " << endl;
for (int i = 0; i < number.size(); i++)
output_table(number[i], variable_v[i], summa_v[i], En_0_v[i]);
n = number.back(); //присваиваем нашему начальному н значение последнего введенного в ветор
summa = summa_v.back();
En_0 = En_0_v.back();
}
else {
number.clear(); //очищаем все векторы
variable_v.clear();
summa_v.clear();
En_0_v.clear();
x = new_x; //присваиваем х новое введеное значение
next_variable = pow(x, 2) / 2; //считаем первый элемент по упрощенной формуле для одного элемента
summa = 0; 

if (alpha == int(alpha)) //если alpha целое, то она выступает в роли счетчика искомых значений
{
if (n <= alpha) //если альфа больше прошлого числа итерций, то считаем новые элементы
cout << "New iteration: " << endl;
for (n += 1; n <= alpha; n++)
calculation(x, n);
}
else { //если alpha типа double, то она выступает в роли погрешности
if (En_0 > alpha)
cout << "New: " << endl;
while (En_0 > alpha) {
n++;
calculation(x, n);
}
}
cout << "Do you want to continue? (if you want to finish type no) "; // выбор пользователя, оставаться ли в программе
cin >> result;
if (result == "NO" || result == "No" || result == "no") { //если пользователь вводит no, то программа завершается
cout << "Thank you for using our program! All the best!";
return 0;
}
}
}
}
